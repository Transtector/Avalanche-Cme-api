#!/bin/bash

### BEGIN INIT INFO
# Provides:          cme-bootstrap
# Required-Start:    $all
# Required-Stop:     $all
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: CME bootstrap service controller
# Description:       Manages CME "system" and "recovery" init
### END INIT INFO

# This script runs under the CME "recovery" init.  It checks for
# valid system update on either "data" partition or external storage.
# If valid system update is found it will be written to "system" partition.
# Script then attempts to init a chroot environment
# on the "system" partition.  If the "system" init fails, this script
# will startup the basic CME API/UI service found on "recovery" partition.

DATA=/data
SYSTEM=/system
EXT=/media/usb0

#============= from https://github.com/fsaintjacques/semver-tool/blob/develop/src/semver

SEMVER_REGEX="^(0|[1-9][0-9]*)\.(0|[1-9][0-9]*)\.(0|[1-9][0-9]*)(\-[0-9A-Za-z-]+(\.[0-9A-Za-z-]+)*)?(\+[0-9A-Za-z-]+(\.[0-9A-Za-z-]+)*)?$"

function warning {
  echo -e "$1" >&2
}

function error {
  echo -e "$1" >&2
  exit 1
}

function validate-version {
  local version=$1
  if [[ "$version" =~ $SEMVER_REGEX ]]; then
    # if a second argument is passed, store the result in var named by $2
    if [ "$#" -eq "2" ]; then
    	local major=${BASH_REMATCH[1]}
    	local minor=${BASH_REMATCH[2]}
    	local patch=${BASH_REMATCH[3]}
    	local prere=${BASH_REMATCH[4]}
    	local build=${BASH_REMATCH[5]}
    	eval "$2=(\"$major\" \"$minor\" \"$patch\" \"$prere\" \"$build\")"
    else
      echo "$version"
    fi
  else
    error "version $version does not match the semver scheme 'X.Y.Z(-PRERELEASE)(+BUILD)'. See help for more information."
  fi
}

function compare-version {
  validate-version "$1" V
  validate-version "$2" V_

  # MAJOR, MINOR and PATCH should compare numericaly
  for i in 0 1 2; do
    case $((${V[$i]} - ${V_[$i]})) in
      0) ;;
      -[0-9]*) echo -1; return 0;;
      [0-9]*) echo 1; return 0 ;;
    esac
  done

  # PREREL should compare with the ASCII order.
  if [[ -n "${V[3]}" ]] && [[ -n "${V_[3]}" ]]; then
    if [[ "${V[3]}" > "${V_[3]}" ]]; then
      echo 1; return 0;
    elif [[ "${V[3]}" < "${V_[3]}" ]]; then
      echo -1; return 0;
    fi
  elif [[ -z "${V[3]}" ]] && [[ -n "${V_[3]}" ]]; then
    echo 1; return 0;
  elif [[ -n "${V[3]}" ]] && [[ -z "${V_[3]}" ]]; then
    echo -1; return 0;
  fi

  echo 0
}

#=============

# if no version set use this
DEFAULT_VERSION=0.0.0

# How to search for CME image files
IMAGE_GLOB="1500-???-v*-SWARE-CME.img.gz"

# Get current system version, if any
if [ -e $SYSTEM/VERSION ]; then
	SYSTEM_VERSION=$( cat $SYSTEM/VERSION )
fi
SYSTEM_VERSION=${SYSTEM_VERSION:- $DEFAULT_VERSION}

function update-log {
	local DATE=$(date +%Y-%m-%d:%H:%M:%S)

	if [ -d $SYSTEM/home/pi/log ]; then
		echo "${DATE} ${1}" >> update.log
	fi

	# always log to recovery log
	echo "${DATE} ${1}" >> /home/pi/log/update.log
}

function backup-system {
	# if there's a current $SYSTEM/VERSION, we'll try to
	# save system's logs and settings to $DATA for restore
	# after new image written
	if [ -e $SYSTEM/VERSION ]; then
		BACKUP="$DATA/cme-${SYSTEM_VERSION}-backup.tar.gz"
		SETTINGS="$SYSTEM/home/pi/Cme/settings.json"
		if [ ! -e "$SETTINGS" ]; then
			SETTINGS=""
		fi
		update-log "Backing up system settings and logs to $BACKUP"
		tar czvf "$BACKUP" "$SETTINGS" "$SYSTEM/home/pi/log"
	fi
}

function restore-system {
	RESTORE="$DATA/cme-${SYSTEM_VERSION}-backup.tar.gz"
	if [ -e "$RESTORE" ]; then
		update-log "Restoring system settings and logs from $RESTORE"
		tar xzvf "$RESTORE"
	fi
}

function print-version {
  	local V=( "${!1}" )

	IFS=.$IFS
	printf '%s' "${V[*]}"
	IFS="${IFS:1}"
}

function parse-version {
	local V=$( echo "$1" | cut -d- -f3 )
	echo "${V#v}"
}

function filter-newest-version {
	#
	# Echo newest version that's greater than current SYSTEM's
	#
	local cur_file	# current image file
	local cur_ver 	# current image file version
	local new_file	# newest image file so far
	local new_ver	# newest image file version
	local sys_ver 	# system version

	sys_ver=$( validate-version "$SYSTEM_VERSION" )
	new_ver=$( validate-version "$DEFAULT_VERSION" )

	while read cur_file
	do
		cur_ver=$( validate-version $( parse-version "$cur_file" ) )

		# if image is newer than system
		if (( $(compare-version "$cur_ver" "$sys_ver") > 0 )); then

			# if image is newer than those found so far
			if (( $(compare-version "$cur_ver" "$new_ver") > 0 )); then

				new_file=$cur_file
				new_ver=$cur_ver
			fi
		fi
	done
	echo "$new_file"
}

#============= Main Bootstrap Process

#
# Part 1. Check for valid system images
#
# If found, the newest (that's newer than SYSTEM) will be written
# to SYSTEM partition and the CME will reboot.  Next time through, 
# the newly written SYSTEM version should match that of any new
# image found, and this section will be skipped.
#

# Check external storage and data partition for updates
IMAGE_UPDATE=$( find $EXT $DATA -name $IMAGE_GLOB | filter-newest-version )
IMAGE_VERSION=$( parse-version "$IMAGE_UPDATE" )

if [[ $IMAGE_UPDATE ]]; then

	# check md5 checksum on image
	if md5sum -c "$IMAGE_UPDATE".md5; then

		# log the update on system log if available
		update-log "System update"

		# backup current system settings, logs, etc...
		backup-system

		# get image size
		IMAGE_SIZE=$(stat -c%s "$IMAGE_UPDATE")

		# device on which SYSTEM is mounted
		SYSTEM_DEV=$(mount | grep -w $SYSTEM | cut -d ' ' -f1)

		update-log "Writing system image $IMAGE_UPDATE"

		# unmount SYSTEM
		umount $SYSTEM_DEV

		# write the image to SYSTEM
		pv "$IMAGE_UPDATE" -s $IMAGE_SIZE | gzip -dc | dd bs=1M conv=sync,noerror iflag=fullblock of="$SYSTEM_DEV"

		# remount SYSTEM
		mount -a

		# resize the SYSTEM to the image's size
		resize2fs $SYSTEM_DEV

		update-log "Done writing system image"

		restore-system

		# add a file to chroot /etc to let login prompts show "SYSTEM"
		echo "SYSTEM" > $SYSTEM/etc/debian_chroot
	
	fi
fi

# 
# Part 2.  Chroot to the SYSTEM partition
#





